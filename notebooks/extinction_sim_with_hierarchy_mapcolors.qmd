---
title: "Similarity-aware vs Random Extinction Selection (MDS + fear ratings)"
format:
  html:
    toc: true
execute:
  warning: false
  message: false
params:
  data_path: "data/coors_rates_2dims.csv"
  id_col: "...1"
  x_cols: ["D1", "D2"]
  fear_col: "fear_mean"
  T: 40              # number of extinction trials (stimuli selected)
  eta: 0.15          # learning rate (0..1)
  sigma_scale: 0.5   # sigma = sigma_scale * median(pairwise distance)
  n_random: 500      # number of random schedules to average over
  seed: 1
  run_hierarchy: true      # include fear-only fixed-order baselines
  hierarchy_orders: ["ascending", "descending"]  # fixed order by baseline fear
---

```{r}

library(tidyverse)
library(here)

set.seed(params$seed)

# ---- Load data ----
dat <- read_csv(here(params$data_path), show_col_types = FALSE) %>%
  rename(id = all_of(params$id_col)) %>%
  mutate(
    id = as.character(id),
    fear0 = .data[[params$fear_col]]
  )


stopifnot(all(params$x_cols %in% names(dat)))
stopifnot("fear0" %in% names(dat))

X <- as.matrix(dat[, params$x_cols])
fear0 <- dat$fear0
N <- nrow(dat)

# ---- Distance matrix + generalization kernel ----
D <- as.matrix(dist(X))
sigma <- params$sigma_scale * median(D[upper.tri(D)])
K <- exp(-(D^2) / (2 * sigma^2))  # K[i,j] in (0,1]; K[i,i] = 1

# Fixed fear-only orders based on baseline fear
order_asc <- order(fear0, decreasing = FALSE)
order_desc <- order(fear0, decreasing = TRUE)

# ---- One-step update: multiplicative reduction generalized by kernel row ----
update_fear <- function(fear, s_idx, eta, K) {
  fear_new <- fear * (1 - eta * K[s_idx, ])
  pmax(fear_new, 0)
}

# ---- Policy: similarity-aware greedy (maximize predicted global fear reduction) ----
# Gain(i) = sum_j fear_j * K[i,j]
choose_similarity_aware <- function(fear, available, K) {
  gains <- rowSums(K[available, , drop = FALSE] * matrix(fear, nrow = length(available), ncol = length(fear), byrow = TRUE))
  available[which.max(gains)]
}

# ---- Simulate one schedule ----
# Policies:
# - "similarity": greedy selection using MDS similarity and current fear
# - "random": random order
# - "ascending": fixed order by baseline fear (low -> high)
# - "descending": fixed order by baseline fear (high -> low)
simulate_schedule <- function(policy = c("similarity", "random", "ascending", "descending"),
                              fear0, K, T, eta, order_asc, order_desc, seed = NULL) {
  policy <- match.arg(policy)
  if (!is.null(seed)) set.seed(seed)

  fear <- fear0
  available <- seq_along(fear0)
  chosen <- integer(0)

  out <- tibble(
    t = 0:T,
    mean_fear = NA_real_
  )
  out$mean_fear[1] <- mean(fear)

  for (tt in 1:T) {
    if (length(available) == 0) {
      # if T > N, allow repeats by resetting availability
      available <- seq_along(fear0)
    }

    s <- if (policy == "random") {
      sample(available, 1)
    } else if (policy == "similarity") {
      choose_similarity_aware(fear, available, K)
    } else if (policy == "ascending") {
      order_asc[order_asc %in% available][1]
    } else { # descending
      order_desc[order_desc %in% available][1]
    }

    fear <- update_fear(fear, s, eta, K)

    chosen <- c(chosen, s)
    available <- setdiff(available, s)

    out$mean_fear[tt + 1] <- mean(fear)
  }

  list(curve = out, chosen = chosen)
}

# ---- Run similarity-aware (deterministic) ----
sim_sim <- simulate_schedule(
  "similarity", fear0, K, params$T, params$eta,
  order_asc = order_asc, order_desc = order_desc,
  seed = params$seed
)
curve_sim <- sim_sim$curve %>% mutate(policy = "Similarity-aware", run = 1)

# ---- Run random many times ----
curves_rand <- map_dfr(seq_len(params$n_random), function(r) {
  sim <- simulate_schedule(
    "random", fear0, K, params$T, params$eta,
    order_asc = order_asc, order_desc = order_desc,
    seed = params$seed + r
  )
  sim$curve %>% mutate(policy = "Random", run = r)
})

# Summarize random curves (band across runs)
curve_rand_sum <- curves_rand %>%
  group_by(t) %>%
  summarise(
    avg_mean_fear = mean(mean_fear, na.rm = TRUE),
    lo = quantile(mean_fear, 0.05, na.rm = TRUE),
    hi = quantile(mean_fear, 0.95, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(policy = "Random")

# ---- Optional: fear-only fixed-order baselines ----
curve_hier <- NULL
hier_sims <- list()
if (isTRUE(params$run_hierarchy)) {
  orders <- params$hierarchy_orders
  hier_sims <- rlang::set_names(vector("list", length(orders)), orders)

  curve_hier <- purrr::map_dfr(orders, function(o) {
    sim <- simulate_schedule(
      o, fear0, K, params$T, params$eta,
      order_asc = order_asc, order_desc = order_desc,
      seed = params$seed
    )
    hier_sims[[o]] <<- sim
    sim$curve %>% mutate(policy = paste0("Fear-only (", o, ")"), run = 1)
  })
}

# ---- Plot learning curves ----
line_df <- bind_rows(
  curve_sim,
  curve_hier
)

p <- ggplot() +
  geom_ribbon(
    data = curve_rand_sum,
    aes(x = t, ymin = lo, ymax = hi),
    alpha = 0.2
  ) +
  geom_line(
    data = curve_rand_sum,
    aes(x = t, y = avg_mean_fear, color = policy, linetype = policy),
    linewidth = 1
  ) +
  geom_line(
    data = line_df,
    aes(x = t, y = mean_fear, color = policy, linetype = policy),
    linewidth = 1
  ) +
  labs(
    x = "Extinction trial (selected stimulus)",
    y = "Mean fear (simulated)",
    title = "Extinction simulation with similarity-based generalization",
    subtitle = paste0(
      "T=", params$T, ", eta=", params$eta,
      ", sigma=", round(sigma, 3),
      " (", params$sigma_scale, "Ã— median distance)"
    ),
    color = NULL,
    linetype = NULL
  ) +
  theme_minimal()

p
```

```{r}
# ---- Simple summary metrics ----
auc <- function(curve_df) {
  # trapezoidal AUC over trials 0..T
  with(curve_df, sum((mean_fear[-1] + mean_fear[-length(mean_fear)]) / 2))
}

t50 <- function(curve_df) {
  # first t where mean fear <= 50% of baseline
  thr <- 0.5 * curve_df$mean_fear[curve_df$t == 0]
  hit <- which(curve_df$mean_fear <= thr)
  if (length(hit) == 0) NA_integer_ else curve_df$t[min(hit)]
}

# ---- Optional hierarchy metrics ----
metrics_hier <- NULL
if (!is.null(curve_hier) && nrow(curve_hier) > 0) {
  metrics_hier <- curve_hier %>%
    group_by(policy) %>%
    summarise(
      auc = auc(cur_data()),
      t50 = t50(cur_data()),
      final_mean_fear = mean_fear[t == params$T],
      .groups = "drop"
    )
}


metrics_sim <- tibble(
  policy = "Similarity-aware",
  auc = auc(curve_sim),
  t50 = t50(curve_sim),
  final_mean_fear = curve_sim$mean_fear[curve_sim$t == params$T]
)

metrics_rand <- curves_rand %>%
  group_by(run) %>%
  summarise(
    auc = auc(cur_data()),
    t50 = t50(cur_data()),
    final_mean_fear = mean_fear[t == params$T],
    .groups = "drop"
  ) %>%
  summarise(
    policy = "Random",
    avg_auc = mean(auc),
    auc_lo = quantile(auc, 0.05),
    auc_hi = quantile(auc, 0.95),
    avg_t50 = median(t50, na.rm = TRUE),
    t50_lo = quantile(t50, 0.05, na.rm = TRUE),
    t50_hi = quantile(t50, 0.95, na.rm = TRUE),
    avg_final_mean_fear = mean(final_mean_fear),
    final_lo = quantile(final_mean_fear, 0.05),
    final_hi = quantile(final_mean_fear, 0.95)
  )

list(
  params = list(T = params$T, eta = params$eta, sigma = sigma),
  similarity_aware = metrics_sim,
  random_summary = metrics_rand,
  hierarchy = metrics_hier,
  improvement_vs_random = tibble(
    metric = c("AUC (percent)", "Final mean fear (percent)", "T50 (trials)"),
    value = c(
      100 * (metrics_rand$avg_auc - metrics_sim$auc) / metrics_rand$avg_auc,
      100 * (metrics_rand$avg_final_mean_fear - metrics_sim$final_mean_fear) / metrics_rand$avg_final_mean_fear,
      metrics_rand$avg_t50 - metrics_sim$t50
    )
  )
)
```

```{r}
# ---- Optional: visualize which stimuli were selected on the MDS map ----
# Build a long table of selected items for each policy we want to display.
sel_df <- tibble(
  id = dat$id,
  x = dat[[params$x_cols[1]]],
  y = dat[[params$x_cols[2]]]
)

sel_points <- bind_rows(
  tibble(
    id = dat$id[sim_sim$chosen],
    chosen_order = seq_along(sim_sim$chosen),
    policy = "Similarity-aware"
  ),
  {
    if (!is.null(hier_sims) && "ascending" %in% names(hier_sims) && !is.null(hier_sims[["ascending"]])) {
      tibble(
        id = dat$id[hier_sims[["ascending"]]$chosen],
        chosen_order = seq_along(hier_sims[["ascending"]]$chosen),
        policy = "Fear-only (ascending)"
      )
    } else {
      tibble(id = character(0), chosen_order = integer(0), policy = character(0))
    }
  },
  {
    if (!is.null(hier_sims) && "descending" %in% names(hier_sims) && !is.null(hier_sims[["descending"]])) {
      tibble(
        id = dat$id[hier_sims[["descending"]]$chosen],
        chosen_order = seq_along(hier_sims[["descending"]]$chosen),
        policy = "Fear-only (descending)"
      )
    } else {
      tibble(id = character(0), chosen_order = integer(0), policy = character(0))
    }
  }
) %>%
  left_join(sel_df, by = "id") %>%
  filter(!is.na(x) & !is.na(y))

ggplot(sel_df, aes(x = x, y = y)) +
  geom_point(alpha = 0.5) +
  geom_point(
    data = sel_points,
    aes(color = policy),
    size = 2
  ) +
  geom_text(
    data = sel_points,
    aes(label = chosen_order, color = policy),
    nudge_y = 0.03,
    size = 3,
    show.legend = FALSE
  ) +
  labs(
    title = "Selected stimuli across policies (order annotated)",
    x = params$x_cols[1], y = params$x_cols[2],
    color = NULL
  ) +
  theme_minimal()

```
